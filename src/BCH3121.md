# 关于BCH(31,21)纠错码的说明及资料

&emsp;&emsp;BCH(31,21)纠错码是POCSAG传输协议使用的纠错码算法。除BCH(31,21)外，POCSAG还使用奇偶校验码。以下是一个典型的POCSAG数据帧结构：

| 位置 |  1位  | 2-21位 | 22-31位 |  32位  |
|----|:----:|:-----:|:------:|:-----:|
| 内容 | 数据类型 |  数据   | BCH纠错码 | 奇偶校验码 |
| 长度 | 1bit | 20bit | 10bit  | 1bit  |

例如同步码**0x7CD215D8**转换成二进制就是

```asm
01111100110100100001010111011000
```

然后按上面的格式分割就是

|  1位  |        2-21位         |   22-31位   |  32位  |
|:----:|:--------------------:|:----------:|:-----:|
|  0   | 11111001101001000010 | 1011101100 |   0   |
| 数据类型 |         数据内容         |   BCH纠错码   | 奇偶校验码 |

可见数据帧为32bit组成的数据包，其中占10bit的BCH纠错码负责校验及纠正前21位的错误，占1bit的奇偶校验码负责校验前31位。

## 1. BCH纠错码

&emsp;&emsp;BCH纠错码的编码规律我并不清楚，在参考了一堆资料后我终于放弃理解了。参考资料我列在下面：

- [BCH Codes](https://math.mit.edu/~shor/18.310/BCH.pdf)
- [6.0 Decoding BCH and RS Codes](https://pages.jh.edu/bcooper8/sigma_files/ERROR_CONTROL_CODING/06dec.pdf)
- [【举例子详细分析】BCH码(BCH code)](https://zhuanlan.zhihu.com/p/95909150)
- [BCH Codes: Constructing them and finding the Syndrome of a Message](https://math.mit.edu/~djk/18.310/18.310F04/bch_codes.html)
- [bch3121.c](http://www.sxlist.com/techref/method/error/bch3121.c)
- ……

总之看得我头疼。反正现在知道BCH(31,21)
就是使用前面21个bit数据计算出一个10bit的纠错码，总共31bit，可以纠正前21bit中2个随机错误应该就行了。BCH(31,21)
的解码代码在[BCH3121.cpp](BCH3121.cpp)、[BCH3121A.c](BCH3121A.c)中都有，只是实现方式不一样，后面再说。

## 2. 奇偶校验码

&emsp;&emsp;奇偶校验码原理很简单，就是数1的个数，然后按情况填1。POCSAG协议采用偶校验，即前31位中有偶数个1，奇偶校验位(第32位)
就填0，不然就填1。比如POCSAG的同步码**0x7CD215D8**展开成二进制就是

```asm
01111100110100100001010111011000
```

前31位中总共有16个1，为偶数，故最后一位填0。反之，若有奇数个1，则填1。如IDLE码**0x7A89C197**，展开后即

```asm
01111010100010011100000110010111
```

前31位有15个1，为奇数，最后一位填0。同理可得32位完整的数据帧中，1的个数总为偶数个。

## 3. 需要完成的事项

**已知：**[BCH3121.cpp](BCH3121.cpp)、[BCH3121A.c](BCH3121A.c)中都有以上两种的纠错码的解码代码，其中：

- [BCH3121.cpp](BCH3121.cpp) 似乎采用了较为标准的解码算法，但是并没有使用奇偶校验码提高准确率/无法应对BCH码本身出错的情况。
- [BCH3121A.c](BCH3121A.c) 似乎使用了两种纠错码，但是原理不明，还需进一步分析。并且由于使用了某种暴力算法解码BCH，BCH的解码效果纯看运气。
- 更详细的还请自己看代码吧。

**目标：结合BCH纠错码、奇偶校验码以最大程度的检查/修正接收过程中产生的错误。**

**要求：** 输入的32位数据帧形式为**uint32_t & (unsigned int &)**
，需要在函数体内改变数据帧的值（通过传入指针的形式，具体实现可以参考上面给的代码文件）来输出修正后的32位数据帧，返回true或false以表示能否完成数据纠错（BCH(
31,21)码无法修正大于2个错误），可以在给出代码的基础上修改。基本上形式如下：

```c++
bool function(uint32_t &data, .../*别的参数随意*/) {
    // 对data进行BCH纠错及奇偶校验
    if (/*能纠错*/) {
        data = data_corrected; // 通过指针把纠错后的数据赋回给data
        return true;
    } else {
        return false;
    }
}
```

目前思路：在[BCH3121.cpp](BCH3121.cpp)
的基础上，先纠错，然后如果返回了false就直接返回false，返回true再进行一次奇偶校验，奇偶校验也通过就返回true，不过就返回false。别的暂时没想到，最好看看[BCH3121A.c](BCH3121A.c)
是怎么结合这两种纠错码的，然后参考一下。
